<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dart AutoScore – Hybrid v1.2</title>
  <style>
    body{margin:0;background:#000;color:#fff;font-family:-apple-system,system-ui,sans-serif}
    .bar{padding:10px;display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button{border:0;border-radius:12px;padding:10px 12px;font-weight:700;background:#1f6feb;color:#fff}
    button.secondary{background:#2b2b2b}
    button.danger{background:#b42318}
    .pill{padding:6px 10px;border-radius:999px;background:#151515;font-size:12px;opacity:.95}
    #wrap{position:relative;width:100vw;height:calc(100vh - 88px);overflow:hidden}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    #hud{position:absolute;left:10px;bottom:10px;max-width:92vw}
    .hint{background:rgba(0,0,0,.45);padding:10px 12px;border-radius:12px;font-size:13px;line-height:1.25}
    input[type="range"]{width:170px}
    input[type="number"]{width:90px;border-radius:10px;border:0;padding:8px 10px}
    .ok{color:#65ff9a}
    .warn{color:#ffd36a}
  </style>
</head>
<body>
  <div class="bar">
    <span class="pill" id="status">Starter…</span>

    <button id="cal" class="secondary">Kalibrer (3 trykk)</button>
    <button id="baseline" class="secondary">Baseline (tom skive)</button>
    <button id="detect">Detect</button>
    <button id="reset" class="danger">Reset</button>

    <span class="pill" id="out">Score: –</span>
    <span class="pill" id="conf">AI: –</span>

    <span class="pill">Thr <span id="thrV">35</span></span>
    <input id="thr" type="range" min="15" max="80" value="35"/>

    <span class="pill">MinArea</span>
    <input id="minArea" type="number" min="100" max="50000" value="900"/>

    <span class="pill">ConfMin <span id="confV">0.65</span></span>
    <input id="confMin" type="range" min="50" max="95" value="65"/>
  </div>

  <div id="wrap">
    <video id="v" autoplay playsinline muted></video>
    <canvas id="c"></canvas>
    <div id="hud">
      <div class="hint" id="hint">
        1) <b>Kalibrer</b>: trykk <b>bull</b> → <b>dobbel 20</b> (topp) → <b>dobbel 6</b> (høyre).<br>
        2) <b>Baseline</b> med tom skive.<br>
        3) Kast 1 pil → <b>Detect</b>.<br>
        Hvis AI er usikker: <span class="warn"><b>Trykk på pilspissen</b></span> for perfekt score.
      </div>
    </div>
  </div>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script>
  (() => {
    const v = document.getElementById('v');
    const c = document.getElementById('c');
    const ctx = c.getContext('2d', { willReadFrequently:true });

    const statusEl = document.getElementById('status');
    const outEl = document.getElementById('out');
    const confEl = document.getElementById('conf');
    const hintEl = document.getElementById('hint');

    const thr = document.getElementById('thr');
    const thrV = document.getElementById('thrV');
    const minAreaEl = document.getElementById('minArea');
    const confMinEl = document.getElementById('confMin');
    const confV = document.getElementById('confV');

    thr.addEventListener('input', ()=> thrV.textContent = thr.value);
    confMinEl.addEventListener('input', ()=> confV.textContent = (confMinEl.value/100).toFixed(2));

    function setStatus(t){ statusEl.textContent = t; }
    function setOut(t){ outEl.textContent = 'Score: ' + t; }
    function setConf(t){ confEl.textContent = 'AI: ' + t; }

    function resize(){
      const r = c.getBoundingClientRect();
      c.width = Math.floor(r.width * devicePixelRatio);
      c.height = Math.floor(r.height * devicePixelRatio);
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener('resize', resize);

    // Geometry
    const SECTORS = [20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5];
    const RING = { innerBull: 6.35/170, outerBull: 15.9/170, tripleIn: 99/170, tripleOut: 107/170, doubleIn: 162/170, doubleOut: 170/170 };

    let calib = { ready:false, center:null, top:null, right:null, R:null, angle0:null };
    let mode = { cal:false, step:0 };

    let baselineMat = null; // cv.Mat grayscale ROI
    let roi = null;         // {x,y,w,h} in full-res video coords

    let lastPoint = null;   // {x,y} full video coords (marker)
    let forceManual = false;

    function draw(){
      const rect = c.getBoundingClientRect();
      ctx.clearRect(0,0,rect.width,rect.height);

      const vw = v.videoWidth, vh = v.videoHeight;
      if(!vw || !vh) return;

      // object-fit:cover mapping
      const sx = rect.width / vw, sy = rect.height / vh;
      const s = Math.max(sx, sy);
      const drawW = vw*s, drawH = vh*s;
      const offX = (rect.width - drawW)/2, offY = (rect.height - drawH)/2;
      const v2s = (p)=>({ x: offX + p.x*s, y: offY + p.y*s });

      const dot = (p, label)=>{
        const sp = v2s(p);
        ctx.beginPath(); ctx.arc(sp.x, sp.y, 8, 0, Math.PI*2);
        ctx.fillStyle='rgba(31,111,235,0.9)'; ctx.fill();
        ctx.fillStyle='#fff'; ctx.font='14px system-ui'; ctx.fillText(label, sp.x+10, sp.y-10);
      };

      if(calib.center) dot(calib.center,'C');
      if(calib.top) dot(calib.top,'20');
      if(calib.right) dot(calib.right,'6');

      if(calib.ready){
        const C = v2s(calib.center);
        const R = calib.R * s;
        const ring=(f)=>{
          ctx.beginPath(); ctx.arc(C.x,C.y,R*f,0,Math.PI*2);
          ctx.strokeStyle='rgba(255,255,255,0.30)'; ctx.lineWidth=2; ctx.stroke();
        };
        ring(RING.outerBull); ring(RING.tripleIn); ring(RING.tripleOut); ring(RING.doubleIn); ring(RING.doubleOut);
      }

      if(lastPoint){
        const sp = v2s(lastPoint);
        ctx.beginPath(); ctx.arc(sp.x, sp.y, 10, 0, Math.PI*2);
        ctx.strokeStyle = forceManual ? 'rgba(255,210,90,0.95)' : 'rgba(0,255,120,0.95)';
        ctx.lineWidth = 3; ctx.stroke();
      }
    }

    function getVideoPointFromTap(clientX, clientY){
      const rect = c.getBoundingClientRect();
      const x = clientX - rect.left, y = clientY - rect.top;
      const vw = v.videoWidth, vh = v.videoHeight;
      const sx = rect.width / vw, sy = rect.height / vh;
      const s = Math.max(sx, sy);
      const drawW = vw*s, drawH = vh*s;
      const offX = (rect.width - drawW)/2, offY = (rect.height - drawH)/2;
      return { x:(x-offX)/s, y:(y-offY)/s };
    }

    function finalizeCal(){
      const C=calib.center, T=calib.top;
      const dx=T.x-C.x, dy=T.y-C.y;
      calib.R = Math.hypot(dx,dy);
      calib.angle0 = Math.atan2(dy,dx);
      calib.ready = true;

      const pad = calib.R * 1.10;
      roi = {
        x: Math.max(0, Math.floor(C.x - pad)),
        y: Math.max(0, Math.floor(C.y - pad)),
        w: Math.floor(Math.min(v.videoWidth  - Math.max(0, Math.floor(C.x - pad)), pad*2)),
        h: Math.floor(Math.min(v.videoHeight - Math.max(0, Math.floor(C.y - pad)), pad*2))
      };

      setStatus('Kalibrert ✅');
      setConf('–');
      hintEl.innerHTML = 'Kalibrert ✅<br>Trykk <b>Baseline</b> (tom skive), kast 1 pil og trykk <b>Detect</b>.';
      draw();
    }

    function scoreFromPoint(P){
      const C=calib.center;
      const dx=P.x-C.x, dy=P.y-C.y;
      const dist=Math.hypot(dx,dy);
      const frac=dist/calib.R;

      if(frac > RING.doubleOut*1.03) return {score:0, detail:'Utenfor'};
      if(frac <= RING.innerBull) return {score:50, detail:'Bull (50)'};
      if(frac <= RING.outerBull) return {score:25, detail:'Bull (25)'};

      let ang = Math.atan2(dy,dx);
      let d = ang - calib.angle0;
      while(d<0) d += Math.PI*2;
      while(d>=Math.PI*2) d -= Math.PI*2;

      const sectorWidth=(Math.PI*2)/20;
      const idx = Math.floor((d + sectorWidth/2)/sectorWidth) % 20;
      const base = SECTORS[idx];

      let mult=1;
      if(frac >= RING.doubleIn) mult=2;
      else if(frac >= RING.tripleIn && frac <= RING.tripleOut) mult=3;

      return {score: base*mult, detail:`${mult===1?'S':(mult===2?'D':'T')} ${base}`};
    }

    // Tap: calibration OR manual scoring (hybrid fallback)
    c.addEventListener('click', (ev)=>{
      const p = getVideoPointFromTap(ev.clientX, ev.clientY);

      if(mode.cal){
        if(mode.step===0){ calib.center=p; mode.step=1; setStatus('Kalibrer: trykk dobbel 20 (topp)'); }
        else if(mode.step===1){ calib.top=p; mode.step=2; setStatus('Kalibrer: trykk dobbel 6 (høyre)'); }
        else { calib.right=p; mode.cal=false; mode.step=0; finalizeCal(); }
        draw();
        return;
      }

      // Manual scoring always available after calibration (this is the hybrid safety net)
      if(calib.ready){
        lastPoint = p;
        forceManual = true;
        const s = scoreFromPoint(p);
        setOut(`${s.score} (${s.detail})`);
        setStatus('Manuell ✅ (trykk pilspiss)');
        setConf('MANUELL');
        draw();
      }
    });

    document.getElementById('cal').addEventListener('click', ()=>{
      mode.cal=true; mode.step=0;
      calib={ready:false,center:null,top:null,right:null,R:null,angle0:null};
      if(baselineMat){ baselineMat.delete(); baselineMat=null; }
      roi=null; lastPoint=null; forceManual=false;
      setOut('–'); setConf('–');
      setStatus('Kalibrer: trykk bull');
      hintEl.innerHTML='Kalibrer: trykk <b>bull</b>.';
      draw();
    });

    document.getElementById('reset').addEventListener('click', ()=>{
      mode.cal=false; mode.step=0;
      calib={ready:false,center:null,top:null,right:null,R:null,angle0:null};
      if(baselineMat){ baselineMat.delete(); baselineMat=null; }
      roi=null; lastPoint=null; forceManual=false;
      setOut('–'); setConf('–');
      setStatus('Reset');
      hintEl.innerHTML='Trykk <b>Kalibrer</b> for å starte.';
      draw();
    });

    function grabMatROIGray(){
      const vw=v.videoWidth, vh=v.videoHeight;
      const off=document.createElement('canvas');
      off.width=vw; off.height=vh;
      const octx=off.getContext('2d', { willReadFrequently:true });
      octx.drawImage(v,0,0,vw,vh);
      const img=octx.getImageData(0,0,vw,vh);

      let mat = cv.matFromImageData(img);
      let gray = new cv.Mat();
      cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY);
      mat.delete();

      const r = new cv.Rect(roi.x, roi.y, roi.w, roi.h);
      let cropped = gray.roi(r);
      gray.delete();
      return cropped; // caller deletes
    }

    function median3(a,b,c){
      let ab = new cv.Mat(), bc = new cv.Mat(), ac = new cv.Mat(), tmp = new cv.Mat();
      cv.max(a,b,ab);
      cv.min(a,b,tmp);
      cv.min(ab,c,bc);
      cv.max(tmp,c,ac);
      cv.min(bc,ac,ab);
      tmp.delete(); bc.delete(); ac.delete();
      return ab; // median
    }

    document.getElementById('baseline').addEventListener('click', async ()=>{
      if(!calib.ready){ alert('Kalibrer først'); return; }
      if(!window.cv || !cv.Mat){ alert('OpenCV laster fortsatt… vent litt.'); return; }

      setStatus('Tar baseline…');
      forceManual = false;
      setConf('–');

      const A=grabMatROIGray(); await new Promise(r=>setTimeout(r,80));
      const B=grabMatROIGray(); await new Promise(r=>setTimeout(r,80));
      const C=grabMatROIGray();

      const M=median3(A,B,C);
      A.delete(); B.delete(); C.delete();

      if(baselineMat) baselineMat.delete();
      baselineMat = M;

      setStatus('Baseline satt ✅');
      hintEl.innerHTML='Baseline satt ✅<br>Kast 1 pil og trykk <b>Detect</b>. Hvis AI er usikker: trykk <b>pilspissen</b>.';
    });

    document.getElementById('detect').addEventListener('click', async ()=>{
      if(!calib.ready){ alert('Kalibrer først'); return; }
      if(!baselineMat){ alert('Trykk Baseline først (tom skive).'); return; }
      if(!window.cv || !cv.Mat){ alert('OpenCV laster fortsatt… vent litt.'); return; }

      setStatus('Analyserer…');
      forceManual = false;

      const A=grabMatROIGray(); await new Promise(r=>setTimeout(r,80));
      const B=grabMatROIGray(); await new Promise(r=>setTimeout(r,80));
      const C=grabMatROIGray();
      const cur = median3(A,B,C);
      A.delete(); B.delete(); C.delete();

      let diff = new cv.Mat();
      cv.absdiff(cur, baselineMat, diff);

      cv.GaussianBlur(diff, diff, new cv.Size(5,5), 0);

      let bin = new cv.Mat();
      cv.threshold(diff, bin, parseInt(thr.value,10), 255, cv.THRESH_BINARY);

      const k = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(5,5));
      cv.morphologyEx(bin, bin, cv.MORPH_OPEN, k);
      cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, k);
      k.delete();

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const minArea = parseInt(minAreaEl.value,10) || 900;

      let best = null, bestScore = -1;
      let secondScore = -1;

      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if(area < minArea){ cnt.delete(); continue; }

        const rect = cv.boundingRect(cnt);
        const aspect = rect.height / Math.max(1, rect.width);
        const score = area * (0.6 + Math.min(2.2, aspect)); // prefer slender-ish blobs

        if(score > bestScore){
          secondScore = bestScore;
          bestScore = score;
          best = { rect, area, score };
        } else if(score > secondScore){
          secondScore = score;
        }
        cnt.delete();
      }

      hierarchy.delete(); contours.delete();

      if(!best){
        setStatus('Fant ingen pil ❌ (senk Thr / senk MinArea / mer side-lys)');
        setConf('0.00');
        cur.delete(); diff.delete(); bin.delete();
        return;
      }

      // Confidence heuristic: how clearly best stands out from runner-up
      const eps = 1e-6;
      const ratio = bestScore / Math.max(eps, bestScore + Math.max(0, secondScore));
      const confMin = (parseInt(confMinEl.value,10) || 65) / 100;

      // point = center of blob (good enough) + convert back to full coords
      const px = roi.x + best.rect.x + best.rect.width/2;
      const py = roi.y + best.rect.y + best.rect.height/2;
      lastPoint = { x:px, y:py };

      if(ratio < confMin){
        // Hybrid fallback: ask user to tap tip
        forceManual = true;
        setStatus('AI usikker ⚠️');
        setConf(`${ratio.toFixed(2)} (tap)`);
        setOut('Trykk pilspissen');
        hintEl.innerHTML = `<span class="warn"><b>AI usikker</b></span> (conf ${ratio.toFixed(2)}). Trykk <b>pilspissen</b> for korrekt score.`;
        draw();

        cur.delete(); diff.delete(); bin.delete();
        return;
      }

      // Confident → auto score
      const s = scoreFromPoint(lastPoint);
      setOut(`${s.score} (${s.detail})`);
      setStatus('Detect ✅');
      setConf(`${ratio.toFixed(2)} ✅`);
      hintEl.innerHTML = `<span class="ok"><b>AI OK</b></span> (conf ${ratio.toFixed(2)}). Hvis feil: trykk pilspissen for å overstyre.`;
      draw();

      cur.delete(); diff.delete(); bin.delete();
    });

    async function startCam(){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"environment" }, audio:false });
        v.srcObject = stream;
        v.addEventListener('loadedmetadata', ()=>{
          resize();
          setStatus('Kamera OK ✅');
          setConf('–');
          setInterval(draw, 250);
        });
      }catch(e){
        setStatus('Kamera-feil ❌');
        alert('Kamera-feil: ' + e);
      }
    }

    let tries=0;
    const waitCv = setInterval(()=>{
      tries++;
      if(window.cv && cv.Mat){
        clearInterval(waitCv);
        setStatus('OpenCV klart ✅');
      }
      if(tries>200){ clearInterval(waitCv); setStatus('OpenCV lastet ikke'); }
    }, 100);

    startCam();
  })();
  </script>
</body>
</html>
